"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _utils = _interopRequireDefault(require("../utils"));

var _constants = require("../constants");

var _erc = require("../erc20");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns the key price in its currency, rather than its decimal representation (Ether vs. Wei for example)
 * @param {*} currencyContractAddress
 * @param {*} lock
 * @param {*} provider
 */
async function _getKeyPrice(lock, provider) {
  const currencyContractAddress = lock.currencyContractAddress || _constants.ZERO;

  if (currencyContractAddress !== _constants.ZERO) {
    // We need to get the decimal value
    const erc20Decimals = await (0, _erc.getErc20Decimals)(currencyContractAddress, provider);
    return _utils.default.toDecimal(lock.keyPrice, erc20Decimals);
  }

  return _utils.default.toWei(lock.keyPrice, 'ether');
}
/**
 * Creates a lock on behalf of the user, using version v6
 * @param {PropTypes.lock} lock
 * @param {function} callback invoked with the transaction hash
 */


async function _default(lock, callback) {
  const unlockContract = await this.getUnlockContract();
  let {
    maxNumberOfKeys
  } = lock;

  if (maxNumberOfKeys === _constants.UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = _constants.ETHERS_MAX_UINT;
  }

  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || _constants.ZERO;
  const lockName = lock.name; // Building a salt from the lock name will prevent creators from creating 2 locks with the same name.

  const salt = _utils.default.sha3(_utils.default.utf8ToHex(lock.name)).substring(0, 26); // 2+24


  const transactionPromise = unlockContract.createLock(lock.expirationDuration, currencyContractAddress, decimalKeyPrice, maxNumberOfKeys, lockName, salt);
  const hash = await this._handleMethodCall(transactionPromise);

  if (callback) {
    callback(null, hash, await transactionPromise);
  } // Let's now wait for the lock to be deployed before we return its address


  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = receipt.logs.map(log => {
    return parser.parseLog(log);
  }).filter(event => event.name === 'NewLock')[0];

  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  } // There was no NewEvent log (transaction failed?)


  return null;
}