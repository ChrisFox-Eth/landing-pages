"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _utils = _interopRequireDefault(require("../utils"));

var _constants = require("../constants");

var _erc = require("../erc20");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Changes the price of keys on a given lock
 * @param {object} params
 * - {PropTypes.address} lockAddress : address of the lock for which we update the price
 * - {string} keyPrice : new price for the lock, as a string (as wei)
 * - {string} decimals : Optional number of decimals (read from contract if unset)
 * - {string} erc20Address : Optional address of ERC20, to retrieve decimals (read from contract if unset)
 * @param {function} callback invoked with the transaction hash
 */
async function _default({
  lockAddress,
  keyPrice,
  decimals,
  erc20Address
}, callback) {
  const lockContract = await this.getLockContract(lockAddress); // If none is set, let's get the current ERC20 address because we need to set one

  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  } // Get the decimals from the contract


  if (decimals == null) {
    if (erc20Address !== _constants.ZERO) {
      decimals = await (0, _erc.getErc20Decimals)(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }

  const actualAmount = _utils.default.toDecimal(keyPrice, decimals);

  const transactionPromise = lockContract.updateKeyPricing(actualAmount, erc20Address || _constants.ZERO);
  const hash = await this._handleMethodCall(transactionPromise);

  if (callback) {
    callback(null, hash, await transactionPromise);
  } // Let's now wait for the keyPrice to have been changed before we return it


  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const priceChangedEvent = receipt.logs.map(log => {
    return parser.parseLog(log);
  }).filter(event => {
    return event.name === 'PricingChanged';
  })[0];

  if (priceChangedEvent) {
    // TODO: also return contract?
    return _utils.default.fromDecimal(priceChangedEvent.args.keyPrice, decimals);
  } // There was no NewEvent log (transaction failed?)


  return null;
}