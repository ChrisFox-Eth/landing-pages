"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getErc20BalanceForAddress = getErc20BalanceForAddress;
exports.getErc20Decimals = getErc20Decimals;
exports.getErc20TokenSymbol = getErc20TokenSymbol;
exports.getAllowance = getAllowance;
exports.approveTransfer = approveTransfer;
exports.default = void 0;

var _ethers = require("ethers");

var _utils = _interopRequireDefault(require("./utils"));

var _erc20abi = _interopRequireDefault(require("./erc20abi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The SAI contract does not have the symbol method implemented correctly
const SAI_ADDRESS = '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359'.toLowerCase(); // This file provides ways to interact with an ERC20 contract

async function getErc20BalanceForAddress(erc20ContractAddress, address, provider) {
  const contract = new _ethers.ethers.Contract(erc20ContractAddress, _erc20abi.default, provider);
  const balance = await contract.balanceOf(address);
  return _utils.default.hexToNumberString(balance);
}
/**
 * Yiels the decimals for en ERC20 contract
 * @param {*} erc20ContractAddress
 * @param {*} provider
 */


async function getErc20Decimals(erc20ContractAddress, provider) {
  const contract = new _ethers.ethers.Contract(erc20ContractAddress, _erc20abi.default, provider);
  let decimals;

  try {
    decimals = await contract.decimals();
  } catch (e) {
    /** Some ERC20 contracts do not have the right decimals method. Defaults to 18 */
    return 18;
  }

  return _utils.default.toNumber(decimals);
}
/**
 * yields the symbole for the ERC20 contract
 * @param {*} erc20ContractAddress
 * @param {*} provider
 */


async function getErc20TokenSymbol(erc20ContractAddress, provider) {
  // The SAI contract has its symbol not implemented
  if (erc20ContractAddress.toLowerCase() === SAI_ADDRESS) {
    return 'SAI';
  }

  const contract = new _ethers.ethers.Contract(erc20ContractAddress, _erc20abi.default, provider);
  let symbol;

  try {
    symbol = await contract.symbol();
  } catch (e) {
    /** Some ERC20 contracts, including DAI do not have the right symbol method. */
    return null;
  }

  return symbol;
}
/**
 * Yields the amount that a purchaser have approved a lock for
 * @param {*} erc20ContractAddress
 * @param {*} purchaser
 * @param {*} lockContractAddress
 * @param {*} provider
 */


async function getAllowance(erc20ContractAddress, lockContractAddress, provider, signer) {
  const purchaser = await signer.getAddress();
  const contract = new _ethers.ethers.Contract(erc20ContractAddress, _erc20abi.default, provider);
  let amount = '0';

  try {
    amount = await contract.allowance(purchaser, lockContractAddress);
  } catch (e) {// if no amount was allowed, some provider will fail.
  }

  return amount;
}

async function approveTransfer(erc20ContractAddress, lockContractAddress, value, provider, signer) {
  const contract = new _ethers.ethers.Contract(erc20ContractAddress, _erc20abi.default, signer);
  return contract.approve(lockContractAddress, value);
}

var _default = {
  approveTransfer,
  getAllowance,
  getErc20BalanceForAddress,
  getErc20Decimals,
  getErc20TokenSymbol
};
exports.default = _default;