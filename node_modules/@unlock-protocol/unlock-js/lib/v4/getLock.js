"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _utils = _interopRequireDefault(require("../utils"));

var _constants = require("../constants");

var _erc = require("../erc20");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Refresh the lock's data.
 * We use the block version
 * @return Promise<Lock>
 */
async function _default(address, provider) {
  const contract = await this.getLockContract(address, provider);
  const attributes = {
    name: x => x,
    keyPrice: x => x,
    expirationDuration: parseInt,
    maxNumberOfKeys: value => {
      if (_utils.default.isInfiniteKeys(value)) {
        return _constants.UNLIMITED_KEYS_COUNT;
      }

      return _utils.default.toNumber(value);
    },
    beneficiary: x => x,
    totalSupply: parseInt,
    tokenAddress: x => x,
    publicLockVersion: parseInt
  }; // Let's load the current block to use to compare versions

  const getBlockNumber = async () => {
    const blockNumber = await provider.getBlockNumber();
    update.asOf = blockNumber;
  };

  const update = {};
  const constantPromises = Object.keys(attributes).map(async attribute => {
    const result = await contract.functions[`${attribute}()`]();
    update[attribute] = attributes[attribute](result[0]); // We cast the value
  });
  constantPromises.push(getBlockNumber());
  await Promise.all(constantPromises);

  if (update.tokenAddress === _constants.ZERO) {
    // If ether, the price is stored as Wei.
    update.keyPrice = _utils.default.fromWei(update.keyPrice, 'ether');
    const balance = await provider.getBalance(address);
    update.balance = _utils.default.fromWei(balance, 'ether');
  } else {
    // Otherwise need to get the erc20's decimal and convert from there, as well as the symbol
    // TODO : make these calls in parallel
    const erc20Decimals = await (0, _erc.getErc20Decimals)(update.tokenAddress, provider);
    const erc20Balance = await (0, _erc.getErc20BalanceForAddress)(update.tokenAddress, address, provider);
    const erc20Symbol = await (0, _erc.getErc20TokenSymbol)(update.tokenAddress, provider);
    update.keyPrice = _utils.default.fromDecimal(update.keyPrice, erc20Decimals);
    update.balance = _utils.default.fromDecimal(erc20Balance, erc20Decimals);
    update.currencySymbol = erc20Symbol;
  } // totalSupply was previously called outstandingKeys. In order to keep compatibility
  // we also assign it. This behavior will eventually be deprecated


  update.outstandingKeys = update.totalSupply;
  delete update.totalSupply; // Using `currencyContractAddress` to be consistent with the createLock method

  if (update.tokenAddress === _constants.ZERO) {
    update.currencyContractAddress = null;
  } else {
    update.currencyContractAddress = update.tokenAddress;
  }

  delete update.tokenAddress;
  return update;
}